<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Cosmos: Creating Interoperable Blockchains — Part 1</title><meta name="description" content="A series on Cosmos, the internet of blockchains powered by the Tendermint consensus engine. By Jae Kwon"><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Cosmos: Creating Interoperable Blockchains — Part 1</h1>
</header>
<section data-field="subtitle" class="p-summary">
A series on Cosmos, the internet of blockchains powered by the Tendermint consensus engine. By Jae Kwon
</section>
<section data-field="body" class="e-content">
<section name="fcd7" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="8bdc" id="8bdc" class="graf graf--h3 graf--leading graf--title">Cosmos: Creating Interoperable Blockchains — Part 1</h3><h4 name="509e" id="509e" class="graf graf--h4 graf-after--h3 graf--subtitle"><em class="markup--em markup--h4-em">A series on </em><a href="http://cosmos.network/" data-href="http://cosmos.network/" class="markup--anchor markup--h4-anchor" rel="noopener" target="_blank"><em class="markup--em markup--h4-em">Cosmos</em></a><em class="markup--em markup--h4-em">, the internet of blockchains powered by the </em><a href="http://tendermint.com/" data-href="http://tendermint.com/" class="markup--anchor markup--h4-anchor" rel="noopener" target="_blank"><em class="markup--em markup--h4-em">Tendermint</em></a><em class="markup--em markup--h4-em"> consensus engine. By </em><a href="https://medium.com/u/c010ef5a0ddf" data-href="https://medium.com/u/c010ef5a0ddf" data-anchor-type="2" data-user-id="c010ef5a0ddf" data-action-value="c010ef5a0ddf" data-action="show-user-card" data-action-type="hover" class="markup--user markup--h4-user" target="_blank"><em class="markup--em markup--h4-em">Jae Kwon</em></a></h4><p name="4bd8" id="4bd8" class="graf graf--p graf-after--h4">There are several ways to create public blockchain applications today. The primary ones are:</p><ol class="postList"><li name="f34a" id="f34a" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Create your own blockchain from scratch, as Satoshi Nakamoto did.</strong> This requires one to two years of full-time dedicated programming to get a completed system, and should not be attempted without a very good reason.</li><li name="16df" id="16df" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Fork an existing blockchain stack like Bitcoin, as various altcoins such as </strong><a href="https://github.com/namecoin/namecoin-core" data-href="https://github.com/namecoin/namecoin-core" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong">Namecoin</strong></a><strong class="markup--strong markup--li-strong"> have done.</strong> This works well if the base codebase is well designed to be modular, but that’s rarely the case.</li><li name="9ff6" id="9ff6" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Write a “smart contract” in an on-chain interpreted language such as </strong><a href="https://solidity.readthedocs.io/en/develop/" data-href="https://solidity.readthedocs.io/en/develop/" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong">Solidity</strong></a>. This is currently the best option for creating simple public blockchain applications, but it requires learning and debugging two levels of complexity — the virtual-machine bytecode interpreter, and the smart contract language.</li></ol><p name="bc0f" id="bc0f" class="graf graf--p graf-after--li">With <a href="http://tendermint.com/" data-href="http://tendermint.com/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Tendermint</a> we introduced a fourth way of creating new public blockchain applications (and by extension, private/consortium apps as well):</p><p name="192a" id="192a" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">4. Write a state-machine in any language (e.g. Golang, Python, etc), and plug it into Tendermint’s consensus engine.</strong> Tendermint is responsible for p2p networking, consensus, and transaction broadcasting. After nodes come to consensus on a block, they push it to the state-machine via a unix-socket protocol called <a href="https://github.com/tendermint/abci" data-href="https://github.com/tendermint/abci" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">ABCI</a> (formerly known as TMSP).</p><p name="02cc" id="02cc" class="graf graf--p graf-after--p">Tendermint solves a lot of problems for blockchains, but when it comes to <em class="markup--em markup--p-em">public</em> blockchains, there are additional common concerns that must be addressed to provide availability. We must balance the desire to provide permissionless and censorship-resistant access with the need to prevent spam and denial-of-service (DoS) attacks. While there are many solutions to this problem, the most common one is to charge a market-rate fee for each transaction. When there is a surge in demand for a blockchain’s resources, the classical supply-vs-demand market mechanism can ensure that your transaction will go through in a timely manner if you pay a sufficiently high fee, and also that sustained DoS attacks will incur significant costs to the attacker.</p><p name="57c2" id="57c2" class="graf graf--p graf-after--p">Ethereum evolved this concept of transaction fees even further by introducing the transaction <em class="markup--em markup--p-em">gas</em>, which priced each CPU operation and prevented infinite for-loops and CPU-heavy smart contracts from hogging the blockchain’s resources. The user can choose to pay however much they want in <em class="markup--em markup--p-em">fees</em>, and can also set the <em class="markup--em markup--p-em">gas_limit</em> (i.e. CPU-operations limit) of the transaction. The value of <em class="markup--em markup--p-em">fees/gas_limit</em> or <em class="markup--em markup--p-em">gas_price</em> is a bid on each CPU-operation. It is the job of the miner to to pack as many transactions into a block as possible such that <em class="markup--em markup--p-em">sum(gas_limit) ≤ block_gas_limit</em>, to maximize fee revenue.</p><p name="49a8" id="49a8" class="graf graf--p graf-after--p">Interestingly, Ethereum chooses to refund a proportion of fees when the transaction does not use all of the gas specified in the <em class="markup--em markup--p-em">gas_limit</em>. This puts the burden of gas-usage prediction on the miner, which may be suboptimal compared to taking all of the fees, and letting the user calculate the expected <em class="markup--em markup--p-em">gas_limit</em> themselves.</p><p name="4845" id="4845" class="graf graf--p graf-after--p">Transaction <em class="markup--em markup--p-em">gas</em> is a powerful concept, and can be applied more generally to blockchain applications that don’t support an interpreted virtual-machine. For example, the <a href="https://gist.github.com/whitepaper#the-hub" data-href="https://gist.github.com/whitepaper#the-hub" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Cosmos Hub</a> can support inter-blockchain (IBC) token-transfer transactions from any Tendermint-powered sidechain (aka zone), regardless of the number of validators. (Validators are nodes that participate in consensus to commit blocks). And yet, the more validators there are in the zone, the more signatures there will be in the block-hash commit of an IBC transaction. We can solve this with gas such that interoperating with blockchains with larger validator-sets costs more. (Of course we could also solve this with <a href="https://pdfs.semanticscholar.org/be29/fa28770bdbbe3d6962d82ab8744658fbfd39.pdf" data-href="https://pdfs.semanticscholar.org/be29/fa28770bdbbe3d6962d82ab8744658fbfd39.pdf" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">cryptographic threshold multi-signature algorithms</a>, but the same concept applies for IBC transactions that require a long Merkle-proof).</p><p name="c3c0" id="c3c0" class="graf graf--p graf-after--p">Taking the lessons on transaction gas that we’ve learned in implementing the Ethereum virtual-machine (which got integrated into ErisDB), we’ve implemented a toy cryptocurrency project called <a href="https://github.com/tendermint/basecoin" data-href="https://github.com/tendermint/basecoin" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Basecoin</a> that will become the basis for the Cosmos Hub. Basecoin (not to be confused with the excellent service <a href="http://coinbase.com/" data-href="http://coinbase.com/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Coinbase</a>) is so named because its goal is to become a basis layer for Tendermint-based cryptocurrency applications. It is a multi-asset system at its core, and is intended to accommodate a wide variety of applications from simple cryptocurrencies to complex systems like Ethereum.</p><pre name="2ab1" id="2ab1" class="graf graf--pre graf-after--p">// A Basecoin user account<br>type Account struct {<br>  PubKey   crypto.PubKey<br>  Sequence int<br>  Balance  Coins<br>}</pre><pre name="3524" id="3524" class="graf graf--pre graf-after--pre">type Coin struct {<br>  Denom  string // e.g. &quot;BTC&quot;, &quot;ATOM&quot;<br>  Amount int64<br>}</pre><pre name="067d" id="067d" class="graf graf--pre graf-after--pre">type Coins []Coin</pre><p name="ce4f" id="ce4f" class="graf graf--p graf-after--pre">Basecoin by default provides the ability to send coins from multiple inputs to multiple outputs with the <em class="markup--em markup--p-em">SendTx</em> transaction. Inputs and outputs are Ethereum-style accounts (rather than UTXOs), so it’s quite a flexible system.</p><p name="2fa7" id="2fa7" class="graf graf--p graf-after--p">But what’s more interesting is the secondary kind of transaction, the <em class="markup--em markup--p-em">AppTx</em> transaction. <em class="markup--em markup--p-em">AppTx</em> transactions are processed by a programmer-provided plugin module. The interface of a Basecoin plugin can be seen below.</p><pre name="d1ce" id="d1ce" class="graf graf--pre graf-after--p">type Plugin interface {<br>    // Name of this plugin, should be short.<br>    Name() string<br>  <br>    // Run a transaction from ABCI DeliverTx<br>    RunTx(store KVStore, ctx CallContext, txBytes []byte) (res abci.Result)<br>  <br>    // Other ABCI message handlers<br>    SetOption(store KVStore, key string, value string) (log string)<br>    InitChain(store KVStore, vals []*abci.Validator)<br>    BeginBlock(store KVStore, height uint64)<br>    EndBlock(store KVStore, height uint64) []*abci.Validator<br>}</pre><pre name="7b20" id="7b20" class="graf graf--pre graf-after--pre">type CallContext struct {<br>    CallerAddress []byte   // Caller&#39;s Address (hash of PubKey)<br>    CallerAccount *Account // Caller&#39;s Account, w/ fee &amp; TxInputs deducted<br>    TxInput       Coins    // The coins that the caller wishes to spend, excluding fees<br>}</pre><p name="db70" id="db70" class="graf graf--p graf-after--pre">The important function is the <em class="markup--em markup--p-em">RunTx</em> interface method, which is what you need to implement in order to extend Basecoin with any functionality you want, whether it be IBC coin-transfer, or an EVM smart-contract call. Perhaps you’d like to program an entirely new smart-contract system based on a novel virtual-machine design. The simplicity of the <em class="markup--em markup--p-em">RunTx</em> interface makes it easy to get started. Behind the scenes, updates to the <em class="markup--em markup--p-em">KVStore</em> get Merkle-ized and persisted to disk automatically. And of course you don’t need to worry about complicated networking and consensus logic because Tendermint takes care of that for you.</p><p name="8a61" id="8a61" class="graf graf--p graf-after--p graf--trailing">Basecoin is still a work-in-progress, and it’s (back) in active development. If you feel like hacking Basecoin, check out our <a href="http://slack.cosmos.network/" data-href="http://slack.cosmos.network/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Slack #basecoin channel</a> and give us a holler!</p></div></div></section><section name="2057" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="3326" id="3326" class="graf graf--p graf--leading graf--trailing"><em class="markup--em markup--p-em">Originally published at </em><a href="https://gist.github.com/a89159d7ae9631835f4ab85c1c63db40" data-href="https://gist.github.com/a89159d7ae9631835f4ab85c1c63db40" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><em class="markup--em markup--p-em">gist.github.com</em></a><em class="markup--em markup--p-em">.</em></p></div></div></section>
</section>
<footer><p class="p-tags">Tagged in <a href="https://medium.com/tag/blockchain" class="p-tag">Blockchains</a>, <a href="https://medium.com/tag/cosmos" class="p-tag">Cosmos</a>, <a href="https://medium.com/tag/tendermint" class="p-tag">Tendermint</a>, <a href="https://medium.com/tag/basecoin" class="p-tag">Basecoin</a>, <a href="https://medium.com/tag/consensus" class="p-tag">Consensus</a></p><p>By <a href="https://medium.com/@nylira" class="p-author h-card">Peng Zhong</a> on <a href="https://medium.com/p/2e7b747515d0"><time class="dt-published" datetime="2017-01-17T08:00:00.000Z">January 17, 2017</time></a>.</p><p><a href="https://medium.com/@nylira/cosmos-creating-interoperable-blockchains-part-1-2e7b747515d0" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on April 23, 2018.</p></footer></article>

</body></html>