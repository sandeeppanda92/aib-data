<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Dev Update—Debugging the Memory Leak in Tendermint</title><meta name="description" content="We received a report about a memory leak on the p2p layer. Aton, Tendermint Core Developer, walks us through his quest to fix the bug."><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Dev Update—Debugging the Memory Leak in Tendermint</h1>
</header>
<section data-field="subtitle" class="p-summary">
We received a report about a memory leak on the p2p layer. Aton, Tendermint Core Developer, walks us through his quest to fix the bug.
</section>
<section data-field="body" class="e-content">
<section name="c82f" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="f49e" id="f49e" class="graf graf--h3 graf--leading graf--title">Dev Update—Debugging the Memory Leak in Tendermint</h3></div><div class="section-inner sectionLayout--outsetColumn"><figure name="4994" id="4994" class="graf graf--figure graf--layoutOutsetCenter graf-after--h3"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1000px; max-height: 563px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 56.3%;"></div><img class="graf-image" data-image-id="1*ZZwHXmOYYS1e4h2RYbmzSQ.png" data-width="3840" data-height="2160" src="https://cdn-images-1.medium.com/max/1000/1*ZZwHXmOYYS1e4h2RYbmzSQ.png"></div></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="d1f8" id="d1f8" class="graf graf--p graf-after--figure">I have spent the last week looking for clues and writing test cases in order to find and fix the memory leak in <a href="http://github.com/tendermint/tendermint/" data-href="http://github.com/tendermint/tendermint/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Tendermint</a>. For those of you who don’t know, Tendermint Core is a Byzantine Fault Tolerant (BFT) middleware that takes a state transition machine — written in any programming language — and securely replicates it on many machines. It is also the foundation of <a href="http://cosmos.network" data-href="http://cosmos.network" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Cosmos</a> — our solution for scaling blockchains.</p><p name="2887" id="2887" class="graf graf--p graf-after--p">Finding a memory leak in Go is not an easy task. However, there is a common set of questions, answers to which will hopefully help you identify the source of a leak. Here is the list:</p><h3 name="d461" id="d461" class="graf graf--h3 graf-after--p">Detecting, Troubleshooting, and Fixing a Memory Leak in Go</h3><h4 name="7915" id="7915" class="graf graf--h4 graf-after--h3">The immediate questions to ask are:</h4><ul class="postList"><li name="b5e5" id="b5e5" class="graf graf--li graf-after--h4">Where is memory leaking to? (<code class="markup--code markup--li-code">go tool pprof</code> with <code class="markup--code markup--li-code">-base</code> flag)</li><li name="bc10" id="bc10" class="graf graf--li graf-after--li">Why is new memory being allocated? (code specific)</li><li name="e54e" id="e54e" class="graf graf--li graf-after--li">Is the number of goroutines growing or not? (<code class="markup--code markup--li-code">runtime.NumGoroutine()</code>)</li><li name="de0e" id="de0e" class="graf graf--li graf-after--li">If the number of goroutines is growing, which of them are new? (<a href="https://github.com/fortytw2/leaktest" data-href="https://github.com/fortytw2/leaktest" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">leaktest</a> or <code class="markup--code markup--li-code">pprof.Lookup(&quot;goroutine&quot;).WriteTo(os.Stdout, 1)</code>)</li><li name="979b" id="979b" class="graf graf--li graf-after--li graf--trailing">If the number of goroutines is not growing, what object(s) hold a reference to the leaking memory? (<code class="markup--code markup--li-code">go tool pprof</code> with <code class="markup--code markup--li-code">-base</code> flag and reading code)</li></ul></div></div></section><section name="af70" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="57b5" id="57b5" class="graf graf--p graf--leading">If you want to know the whole story, please keep reading.</p><h3 name="0cd6" id="0cd6" class="graf graf--h3 graf-after--p">Part 1. Discovery</h3><p name="e202" id="e202" class="graf graf--p graf-after--h3">It all started with one of our users <a href="https://github.com/cosmos/gaia/issues/108" data-href="https://github.com/cosmos/gaia/issues/108" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">reporting a memory leak</a> (<em class="markup--em markup--p-em">thanks Martin</em>), while he was trying to sync with the latest testnet (<code class="markup--code markup--p-code">gaia-2</code>). And 615MB after just a few minutes at block ~230k certainly does sound like one. Jeez!</p><p name="d7c6" id="d7c6" class="graf graf--p graf-after--p">First thing I did is try to replicate this manually by spinning up a new node and connecting to the same testnet. I took advantage of existing <code class="markup--code markup--p-code">http://localhost:46657/write_heap_profile?filename=_</code> RPC endpoint and created two heap dumps: one at the start, another after approximately 10 minutes of syncing. Then I compared them using <code class="markup--code markup--p-code">go tool pprof</code> .</p><pre name="606b" id="606b" class="graf graf--pre graf-after--p">go tool pprof -base /tmp/mem1.mprof /tmp/mem2.mprof</pre><p name="aa5c" id="aa5c" class="graf graf--p graf-after--pre">Immediately I noticed <a href="https://github.com/cosmos/gaia/issues/108#issuecomment-358742047" data-href="https://github.com/cosmos/gaia/issues/108#issuecomment-358742047" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">a lot of memory</a> is occupied by <code class="markup--code markup--p-code">newChannel</code> and <code class="markup--code markup--p-code">RepeatTimer.</code> The trail went all the way up to the <code class="markup--code markup--p-code">reconnectToPeer</code> function. That was weird because we’re not creating any new peers (some of them were just failing due to timeouts and Tendermint tried to reconnect).</p><figure name="e5fc" id="e5fc" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 349px; max-height: 758px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 217.20000000000002%;"></div><img class="graf-image" data-image-id="1*uJQPslhaFLkQP9_s1G0Irg.png" data-width="349" data-height="758" src="https://cdn-images-1.medium.com/max/800/1*uJQPslhaFLkQP9_s1G0Irg.png"></div></figure><figure name="f9fa" id="f9fa" class="graf graf--figure graf-after--figure"><div class="aspectRatioPlaceholder is-locked" style="max-width: 513px; max-height: 386px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 75.2%;"></div><img class="graf-image" data-image-id="1*Bd7Kf8txX-pzUf26WLh0fg.png" data-width="513" data-height="386" src="https://cdn-images-1.medium.com/max/800/1*Bd7Kf8txX-pzUf26WLh0fg.png"></div></figure><h3 name="3a45" id="3a45" class="graf graf--h3 graf-after--figure">Part 2. Mistake</h3><p name="deed" id="deed" class="graf graf--p graf-after--h3">Here I made a mistake. I thought I pinpointed the exact place where the memory is leaking. So I went and wrote a test case for <code class="markup--code markup--p-code">p2p/Switch</code>, where I create a peer, close the connection (simulate a timeout), wait until Tendermint reconnects and repeat this 100 times. Before and after, I took snapshots of the heap and later used them to find where memory is going.</p><p name="2423" id="2423" class="graf graf--p graf-after--p">The test-case looked like this:</p><pre name="4aba" id="4aba" class="graf graf--pre graf-after--p">// memory heap before<br>f, err := os.Create(“/tmp/mem1.mprof”)<br>if err != nil {<br>  t.Fatal(err)<br>}<br>pprof.WriteHeapProfile(f)<br>f.Close()</pre><pre name="33af" id="33af" class="graf graf--pre graf-after--pre"><br>// create a peer<br>// simulate failure by closing the connection<br>// wait until Tendermint reconnects to peer<br>// repeat 100 times</pre><pre name="7f52" id="7f52" class="graf graf--pre graf-after--pre"><br>// call GC manually<br>runtime.GC()</pre><pre name="7b55" id="7b55" class="graf graf--pre graf-after--pre"><br>// memory heap after<br>f, err := os.Create(“/tmp/mem2.mprof”)<br>if err != nil {<br>  t.Fatal(err)<br>}<br>pprof.WriteHeapProfile(f)<br>f.Close()</pre><p name="945f" id="945f" class="graf graf--p graf-after--pre">Indeed, the test showed leaking <code class="markup--code markup--p-code">newChannel</code> and <code class="markup--code markup--p-code">RepeatTimer</code>. But I still had no clue about why this was happening. I spent a few days reading various resources and source code, trying different instruments and <a href="https://stackoverflow.com/questions/48499573/is-there-a-way-to-know-who-holds-a-reference-to-an-object-in-go" data-href="https://stackoverflow.com/questions/48499573/is-there-a-way-to-know-who-holds-a-reference-to-an-object-in-go" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">asking people</a> for advice on StackOverflow.</p><p name="13c1" id="13c1" class="graf graf--p graf-after--p">One advice was particularly interesting: <strong class="markup--strong markup--p-strong">look for running goroutines</strong>. So at the end of the test, I added:</p><pre name="4c38" id="4c38" class="graf graf--pre graf-after--p">time.Sleep(10 * time.Second)<br>pprof.Lookup(“goroutine”).WriteTo(os.Stdout, 1)</pre><p name="ef09" id="ef09" class="graf graf--p graf-after--pre"><em class="markup--em markup--p-em">In the process, I also discovered a great tool — </em><a href="https://github.com/fortytw2/leaktest" data-href="https://github.com/fortytw2/leaktest" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><em class="markup--em markup--p-em">leaktest</em></a><em class="markup--em markup--p-em">, which does almost the same, except it removes runtime and testing related goroutines, so it’s easy to spot leaking goroutines. Plus it makes a test fail if in the end there are still some goroutines running.</em></p><p name="1199" id="1199" class="graf graf--p graf-after--p">No useful results. However, now I knew it was not goroutines that were the issue. I figured out there must be something wrong with my test case. Of course! How could I be so stupid? The culprit was testing using <code class="markup--code markup--p-code">TestReactor</code> (<a href="https://martinfowler.com/articles/mocksArentStubs.html" data-href="https://martinfowler.com/articles/mocksArentStubs.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">spy</a>), which <a href="https://github.com/tendermint/tendermint/blob/747b73cb95dab52ee1076ce83dcc92dca86ef93a/p2p/switch_test.go#L67" data-href="https://github.com/tendermint/tendermint/blob/747b73cb95dab52ee1076ce83dcc92dca86ef93a/p2p/switch_test.go#L67" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">keeps track of peers</a> and <a href="https://github.com/tendermint/tendermint/blob/747b73cb95dab52ee1076ce83dcc92dca86ef93a/p2p/switch_test.go#L73" data-href="https://github.com/tendermint/tendermint/blob/747b73cb95dab52ee1076ce83dcc92dca86ef93a/p2p/switch_test.go#L73" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">does not remove them</a>.</p><pre name="8374" id="8374" class="graf graf--pre graf-after--p">tr.peersAdded = append(tr.peersAdded, peer)</pre><p name="48ea" id="48ea" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">TestReactor</code> was the one holding reference to all peers (both added and removed). This is why Go was not able to garbage collect them.</p><figure name="fbe3" id="fbe3" class="graf graf--figure graf--iframe graf-after--p"><iframe src="https://www.youtube.com/embed/Ti3mWTKXIgk?feature=oembed" width="700" height="393" frameborder="0" scrolling="no"></iframe></figure><p name="4f18" id="4f18" class="graf graf--p graf-after--figure">The mistake I was talking above was<strong class="markup--strong markup--p-strong"> jumping to a unit test instead of writing an integration test</strong>. Then it all became clear. I knew what I needed to do. I should have written the same test case but for the whole program (basically wrapping <code class="markup--code markup--p-code">main.main()</code>) rather than something, which is using a <a href="https://martinfowler.com/articles/mocksArentStubs.html" data-href="https://martinfowler.com/articles/mocksArentStubs.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">spy</a> (<code class="markup--code markup--p-code">TestReactor</code>).</p><h3 name="5872" id="5872" class="graf graf--h3 graf-after--p">Part 3. Happy Ending</h3><p name="2e8d" id="2e8d" class="graf graf--p graf-after--h3">In case of Tendermint, the entry point (analogue of <code class="markup--code markup--p-code">main.main()</code> ) is creating and running a <code class="markup--code markup--p-code">Node</code> .</p><pre name="f311" id="f311" class="graf graf--pre graf-after--p">// create &amp; start node<br>n, err := DefaultNewNode(config, log.TestingLogger())<br>...</pre><pre name="c54b" id="c54b" class="graf graf--pre graf-after--pre">// memory heap before<br>f, err := os.Create(“/tmp/mem1.mprof”)<br>if err != nil {<br>  t.Fatal(err)<br>}<br>pprof.WriteHeapProfile(f)<br>f.Close()</pre><pre name="f230" id="f230" class="graf graf--pre graf-after--pre">// stop a peer 100 times</pre><pre name="e6f3" id="e6f3" class="graf graf--pre graf-after--pre">// call GC manually<br>runtime.GC()</pre><pre name="7f49" id="7f49" class="graf graf--pre graf-after--pre">// memory heap after<br>f, err := os.Create(“/tmp/mem2.mprof”)<br>if err != nil {<br>  t.Fatal(err)<br>}<br>pprof.WriteHeapProfile(f)<br>f.Close()</pre><pre name="dd3b" id="dd3b" class="graf graf--pre graf-after--pre">// stop node<br>n.Stop()</pre><pre name="7919" id="7919" class="graf graf--pre graf-after--pre">// dump all running goroutines<br>time.Sleep(10 * time.Second)<br>pprof.Lookup(“goroutine”).WriteTo(os.Stdout, 1)</pre><p name="df99" id="df99" class="graf graf--p graf-after--pre">2 minutes later I discovered the real reason:</p><pre name="1557" id="1557" class="graf graf--pre graf-after--p">114 @ 0x42f2bc 0x42f3ae 0x440794 0x4403b9 0x468002 0x9fe32d 0x9ff78f 0xa025ed 0x45e571</pre><pre name="2155" id="2155" class="graf graf--pre graf-after--pre"># 0x4403b8 sync.runtime_Semacquire+0x38 /usr/lib/go-1.9/src/runtime/sema.go:56<br># 0x468001 sync.(*WaitGroup).Wait+0x71 /usr/lib/go-1.9/src/sync/waitgroup.go:131<br># 0x9fe32c <a href="http://github.com/tendermint/tendermint/vendor/github.com/tendermint/tmlibs/clist.%28*CList%29.FrontWait+0x2c" data-href="http://github.com/tendermint/tendermint/vendor/github.com/tendermint/tmlibs/clist.(*CList).FrontWait+0x2c" class="markup--anchor markup--pre-anchor" rel="noopener" target="_blank">github.com/tendermint/tendermint/vendor/github.com/tendermint/tmlibs/clist.(*CList).FrontWait+0x2c</a> /home/vagrant/go/src/<a href="http://github.com/tendermint/tendermint/vendor/github.com/tendermint/tmlibs/clist/clist.go:233" data-href="http://github.com/tendermint/tendermint/vendor/github.com/tendermint/tmlibs/clist/clist.go:233" class="markup--anchor markup--pre-anchor" rel="noopener" target="_blank">github.com/tendermint/tendermint/vendor/github.com/tendermint/tmlibs/clist/clist.go:233</a><br># 0x9ff78e <a href="http://github.com/tendermint/tendermint/mempool.%28*Mempool%29.TxsFrontWait+0x2e" data-href="http://github.com/tendermint/tendermint/mempool.(*Mempool).TxsFrontWait+0x2e" class="markup--anchor markup--pre-anchor" rel="noopener" target="_blank">github.com/tendermint/tendermint/mempool.(*Mempool).TxsFrontWait+0x2e</a> /home/vagrant/go/src/<a href="http://github.com/tendermint/tendermint/mempool/mempool.go:184" data-href="http://github.com/tendermint/tendermint/mempool/mempool.go:184" class="markup--anchor markup--pre-anchor" rel="noopener" target="_blank">github.com/tendermint/tendermint/mempool/mempool.go:184</a><br># 0xa025ec <a href="http://github.com/tendermint/tendermint/mempool.%28*MempoolReactor%29.broadcastTxRoutine+0x25c" data-href="http://github.com/tendermint/tendermint/mempool.(*MempoolReactor).broadcastTxRoutine+0x25c" class="markup--anchor markup--pre-anchor" rel="noopener" target="_blank">github.com/tendermint/tendermint/mempool.(*MempoolReactor).broadcastTxRoutine+0x25c</a> /home/vagrant/go/src/<a href="http://github.com/tendermint/tendermint/mempool/reactor.go:120" data-href="http://github.com/tendermint/tendermint/mempool/reactor.go:120" class="markup--anchor markup--pre-anchor" rel="noopener" target="_blank">github.com/tendermint/tendermint/mempool/reactor.go:120</a></pre><p name="7f3f" id="7f3f" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">MempoolReactor</code> creates a broadcast routine for each peer. It can block on an empty <code class="markup--code markup--p-code">CList</code> forever unless there are transactions coming in. And since there are no transactions during sync, this goroutine will just sit there, holding onto the peer too. If we’re constantly reconnecting to some peer, old instances are not garbage collected, leading to the memory leak.</p><p name="8818" id="8818" class="graf graf--p graf-after--p">The leak was <a href="https://github.com/tendermint/tendermint/pull/1173" data-href="https://github.com/tendermint/tendermint/pull/1173" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">successfully fixed</a> and included in the next release of Tendermint (0.16).</p><div name="1f16" id="1f16" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://github.com/tendermint/tendermint/pull/1173" data-href="https://github.com/tendermint/tendermint/pull/1173" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://github.com/tendermint/tendermint/pull/1173"><strong class="markup--strong markup--mixtapeEmbed-strong">fix memory leak in mempool reactor by melekes · Pull Request #1173 · tendermint/tendermint</strong><br><em class="markup--em markup--mixtapeEmbed-em">Leaking goroutine: 114 @ 0x42f2bc 0x42f3ae 0x440794 0x4403b9 0x468002 0x9fe32d 0x9ff78f 0xa025ed 0x45e571 # 0x4403b8…</em>github.com</a><a href="https://github.com/tendermint/tendermint/pull/1173" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="c1fd41a86219ea2874cb1849304e8167" data-thumbnail-img-id="0*UbdtI0igko4FuiXR." style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*UbdtI0igko4FuiXR.);"></a></div><p name="ab8d" id="ab8d" class="graf graf--p graf-after--mixtapeEmbed"><strong class="markup--strong markup--p-strong">Lessons learned:</strong></p><ul class="postList"><li name="8425" id="8425" class="graf graf--li graf-after--p">avoid unnecessary blocking</li><li name="44e7" id="44e7" class="graf graf--li graf-after--li">use leaktest in integration tests (especially if code is spawning new goroutines)</li></ul><p name="236c" id="236c" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Resources:</strong></p><ul class="postList"><li name="d063" id="d063" class="graf graf--li graf-after--p"><a href="https://medium.com/golangspec/goroutine-leak-400063aef468" data-href="https://medium.com/golangspec/goroutine-leak-400063aef468" class="markup--anchor markup--li-anchor" target="_blank">Goroutine leak</a></li><li name="cc9e" id="cc9e" class="graf graf--li graf-after--li"><a href="https://blog.golang.org/profiling-go-programs" data-href="https://blog.golang.org/profiling-go-programs" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Profiling Go Programs</a></li><li name="9dc0" id="9dc0" class="graf graf--li graf-after--li graf--trailing"><a href="https://www.youtube.com/watch?v=ydWFpcoYraU" data-href="https://www.youtube.com/watch?v=ydWFpcoYraU" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Finding Memory Leaks in Go Programs — Oleg Shaldybin</a></li></ul></div></div></section>
</section>
<footer><p class="p-tags">Tagged in <a href="https://medium.com/tag/tendermint" class="p-tag">Tendermint</a>, <a href="https://medium.com/tag/golang" class="p-tag">Golang</a>, <a href="https://medium.com/tag/software-testing" class="p-tag">Software Testing</a>, <a href="https://medium.com/tag/technical-writing" class="p-tag">Technical Writing</a>, <a href="https://medium.com/tag/distributed-systems" class="p-tag">Distributed Systems</a></p><p>By <a href="https://medium.com/@anton.kalyaev" class="p-author h-card">Anton Kaliaev</a> on <a href="https://medium.com/p/210186711420"><time class="dt-published" datetime="2018-02-13T18:39:18.300Z">February 13, 2018</time></a>.</p><p><a href="https://medium.com/@anton.kalyaev/debugging-the-memory-leak-in-tendermint-210186711420" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on April 23, 2018.</p></footer></article>

</body></html>