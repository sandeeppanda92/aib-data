<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Understanding the value proposition of Cosmos</title><meta name="description" content="Cosmos is generally seen as an interoperability solution, something to connect blockchains together. While it is certainly a part of what…"><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Understanding the value proposition of Cosmos</h1>
</header>
<section data-field="subtitle" class="p-summary">
Cosmos is generally seen as an interoperability solution, something to connect blockchains together. While it is certainly a part of what…
</section>
<section data-field="body" class="e-content">
<section name="d551" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--outsetColumn"><figure name="b568" id="b568" class="graf graf--figure graf--layoutOutsetCenter graf--leading"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1000px; max-height: 563px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 56.3%;"></div><img class="graf-image" data-image-id="1*8W0XcYzbcCKTdAIRcbi5VQ.jpeg" data-width="3840" data-height="2160" data-is-featured="true" src="https://cdn-images-1.medium.com/max/1000/1*8W0XcYzbcCKTdAIRcbi5VQ.jpeg"></div></figure></div><div class="section-inner sectionLayout--insetColumn"><h3 name="79ae" id="79ae" class="graf graf--h3 graf-after--figure graf--title"><em class="markup--em markup--h3-em">Understanding the value proposition of Cosmos</em></h3><p name="5acc" id="5acc" class="graf graf--p graf-after--h3">Cosmos is generally seen as an interoperability solution, something to connect blockchains together. While it is certainly a part of what we are trying to achieve, this conception of Cosmos leaves out many important pieces. Cosmos is much, much more than just an interoperability solution. To understand why, let us try to explain the vision behind Cosmos, starting from the beginning.</p><h3 name="257d" id="257d" class="graf graf--h3 graf-after--p">What is a blockchain?</h3><p name="ece1" id="ece1" class="graf graf--p graf-after--h3">In short, a blockchain is a deterministic state machine replicated on nodes that do not necessarily trust each other. There is a state, which can represent different things depending on the application (e.g. token balances for accounts), and transactions, that modify the state. From an architecture standpoint, blockchains can be divided into three conceptual layers:</p><ul class="postList"><li name="5128" id="5128" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">Networking</em>:</strong> Responsible for the propagation of transactions.</li><li name="f550" id="f550" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">Consensus</em>:</strong> Enables validator nodes to agree on the next set of transactions to process (i.e. add blocks of transactions to the blockchain).</li><li name="58ee" id="58ee" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">Application</em>:</strong> Responsible for updating the state given a set of transactions, i.e. processing transactions</li></ul><figure name="0845" id="0845" class="graf graf--figure graf-after--li"><div class="aspectRatioPlaceholder is-locked" style="max-width: 441px; max-height: 321px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 72.8%;"></div><img class="graf-image" data-image-id="1*wZrMqYyYHnEXGGe6O5W6aQ.jpeg" data-width="441" data-height="321" src="https://cdn-images-1.medium.com/max/800/1*wZrMqYyYHnEXGGe6O5W6aQ.jpeg"></div><figcaption class="imageCaption">Simplified blockchain architecture</figcaption></figure><p name="b3da" id="b3da" class="graf graf--p graf-after--figure">The <em class="markup--em markup--p-em">networking</em> layer makes sure that each node receives transactions. The <em class="markup--em markup--p-em">consensus</em> layer makes sure that each node agrees on the same transactions to modify their local state. As for the <em class="markup--em markup--p-em">application</em> layer, it processes transactions. Given a transaction and a state, the application will return a new state. In Bitcoin for example, the state is a list of balances for each account (in reality, it’s a list of UTXO, short for Unspent Transaction Output, but let’s call them balances for the sake of simplicity), and transactions modify the state by changing these balances. In the case of Ethereum, the application is a virtual machine. Each transaction goes through this virtual machine and modifies the state according to the specific smart contract that is called within it.</p><h3 name="080a" id="080a" class="graf graf--h3 graf-after--p">The birth of Tendermint</h3><p name="174a" id="174a" class="graf graf--p graf-after--h3">Before <a href="https://tendermint.com/" data-href="https://tendermint.com/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Tendermint</a>, building a blockchain required building all three layers from the ground up. It was such a tedious task that most developers preferred forking the Bitcoin codebase, thereby being constrained by the limitations of the Bitcoin protocol. Then, Ethereum came in and greatly simplified the development of decentralised applications by providing a Virtual-Machine blockchain on which anyone could deploy custom logic in the form of Smart Contracts. But it did not simplify the development of blockchains themselves, as Go-Ethereum remained a very monolithic tech stack that is difficult to hard-fork from, much like Bitcoin. That is where Tendermint came in.</p><p name="e064" id="e064" class="graf graf--p graf-after--p">The goal of Tendermint is to provide the <em class="markup--em markup--p-em">networking</em> and <em class="markup--em markup--p-em">consensus</em> layers of a blockchain as a generic engine on which arbitrary applications can be built. With Tendermint, developers only have to worry about the <em class="markup--em markup--p-em">application</em> layer of their blockchain, thereby saving them hundreds of hours of development work. Note that Tendermint also designates the name of the <a href="https://github.com/tendermint/tendermint/wiki/Byzantine-Consensus-Algorithm" data-href="https://github.com/tendermint/tendermint/wiki/Byzantine-Consensus-Algorithm" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">byzantine fault tolerant consensus algorithm</a> used within the Tendermint Core engine. For more on consensus protocols, you can check this cool <a href="https://softwareengineeringdaily.com/2018/03/26/consensus-systems-with-ethan-buchman/" data-href="https://softwareengineeringdaily.com/2018/03/26/consensus-systems-with-ethan-buchman/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">podcast</a>.</p><figure name="c329" id="c329" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 411px; max-height: 321px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 78.10000000000001%;"></div><img class="graf-image" data-image-id="1*K44yfQ-uiXosLtOCPUK8Dw.jpeg" data-width="411" data-height="321" src="https://cdn-images-1.medium.com/max/800/1*K44yfQ-uiXosLtOCPUK8Dw.jpeg"></div><figcaption class="imageCaption">Tendermint ABCI architecture</figcaption></figure><p name="a4b9" id="a4b9" class="graf graf--p graf-after--figure">The <a href="https://github.com/tendermint/tendermint" data-href="https://github.com/tendermint/tendermint" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Tendermint Core engine</a> is connected to the application by a socket protocol called the <a href="https://github.com/tendermint/abci" data-href="https://github.com/tendermint/abci" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Application Blockchain Interface</a>. This protocol can be wrapped in any language, so that developers can choose the programming language they prefer to build their application. <strong class="markup--strong markup--p-strong">But this is not all</strong>. The goal of Tendermint is to provide developers with a tool that is not only practical, but also highly performant. Here are the properties that make Tendermint a state-of-the-art blockchain engine:</p><ul class="postList"><li name="4cd2" id="4cd2" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Public or private blockchain capable:</strong> Tendermint only handles <em class="markup--em markup--li-em">networking</em> and <em class="markup--em markup--li-em">consensus</em> for the blockchain, meaning that it helps nodes propagate transactions and validators agree on a set of transactions to append to the blockchain. It is the role of the <em class="markup--em markup--li-em">application</em> layer to define how the validator set is constituted. Developers can therefore build both public and private blockchains on top of the Tendermint engine. If the application defines that validators are elected based on how many coins have been bonded to them, then the blockchain can be characterised as Proof-Of-Stake. If however the application defines that only a restricted set of pre-authorized entities can be validators, then the blockchain can be characterised as permissionned, private or Proof-Of-Authority. Developers have all the freedom to customize the rules that define how the validator set of their blockchain changes.</li><li name="9bc3" id="9bc3" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">High Performance:</strong> Tendermint Core can have a block time on the order of 1 second and can handle thousands of transactions per second.</li><li name="1377" id="1377" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Instant finality:</strong> A property of the Tendermint consensus algorithm is instant finality, meaning that forks are never created, as long as less than a third of the validators are malicious (byzantine). Users can be sure their transactions are finalized as soon as a block is created.</li><li name="b7dd" id="b7dd" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Security:</strong> Tendermint consensus is not only fault tolerant, it’s optimally Byzantine fault-tolerant, with accountability. If the blockchain forks, there is a way to determine liability.</li></ul><p name="f679" id="f679" class="graf graf--p graf-after--li">Another cool thing with Tendermint is that the ABCI is so modular that you can port existing blockchain codebases onto it. For example, you can take the Ethereum virtual machine codebase and plug it in on top of Tendermint. Indeed, we did that, it is called <a href="https://ethermint.zone/" data-href="https://ethermint.zone/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Ethermint</a>. Ethermint works exactly like Ethereum, but also benefits from all the nice properties of Tendermint listed above. All the existing Ethereum tools (Truffle, Metamask, ..) are compatible with Ethermint, and you can port your smart contracts there without any additional work.</p><h3 name="6734" id="6734" class="graf graf--h3 graf-after--p">Bridging it all together — IBC</h3><p name="a67c" id="a67c" class="graf graf--p graf-after--h3">We now have our first building block: Tendermint. With it, developers can easily develop highly-performant blockchains without having to worry about the <em class="markup--em markup--p-em">networking</em> or <em class="markup--em markup--p-em">consensus</em> layers. These blockchains all have different <em class="markup--em markup--p-em">application</em> layers, but they share the same <em class="markup--em markup--p-em">networking</em> and <em class="markup--em markup--p-em">consensus</em> stack. Because of this, it becomes easy to connect them with each other.</p><p name="8bf4" id="8bf4" class="graf graf--p graf-after--p">The connection between Tendermint blockchains is achieved through a protocol called IBC, short for <a href="https://blog.cosmos.network/developer-deep-dive-cosmos-ibc-5855aaf183fe" data-href="https://blog.cosmos.network/developer-deep-dive-cosmos-ibc-5855aaf183fe" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Inter-Blockchain Communication Protocol</a>. IBC leverages the instant finality property of Tendermint to allow heterogenous chains to exchange value (i.e. tokens) with each other. Let us take a closer look at how IBC works, and how it enables the creation of <a href="https://cosmos.network/whitepaper" data-href="https://cosmos.network/whitepaper" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Cosmos</a>, a network of blockchains.</p><h4 name="ebf7" id="ebf7" class="graf graf--h4 graf-after--p">Heterogenous chains</h4><p name="c48e" id="c48e" class="graf graf--p graf-after--h4">First, we need to explain what we mean by heterogenous chains. Essentially, it comes down to two things:</p><ul class="postList"><li name="dcd5" id="dcd5" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Different layers:</strong> Heterogenous chains can have different layers, meaning they can differ in how they implement the <em class="markup--em markup--li-em">networking</em>, <em class="markup--em markup--li-em">consensus</em> and <em class="markup--em markup--li-em">application</em> parts. This works with a few restrictions, the main one being that the <em class="markup--em markup--li-em">consensus</em> layer must have fast finality. Proof-Of-Work chains do not fall in this category, as they have probabilistic finality.</li><li name="5c90" id="5c90" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Sovereignty: </strong>Every blockchain is maintained by a set of validators, whose job is to agree on the next block to commit to the blockchain. In Proof-Of-Work, validators are called miners. A sovereign blockchain is a blockchain with its own validator set. In many instances it is important for blockchains to be sovereign, as validators are ultimately responsible for modifying the state. In Ethereum, applications are all run by a common set of validators. Because of this, each application only has limited sovereignty.</li></ul><p name="965b" id="965b" class="graf graf--p graf-after--li">IBC allows heterogenous chains to exchange tokens. This means that blockchains with different applications and validator sets are interoperable. This is a very important feat, as it gives maximum flexibility to each blockchain. For example, it allows public and private chains to exchange tokens with each other.</p><h4 name="eede" id="eede" class="graf graf--h4 graf-after--p">How IBC works</h4><p name="bf99" id="bf99" class="graf graf--p graf-after--h4">The principle behind IBC is fairly simple. Let’s take an example where an account on chain A wants to send 10 tokens X on chain B. First, these tokens are locked on chain A. Then, a proof that these 10 tokens X are locked is relayed from chain A to chain B. Chain B tracks the validator set of chain A. If the proof is signed by more than 2/3rd of chain A’s validators, then it is valid, and 10 tokens X are created on chain B.</p><p name="6da1" id="6da1" class="graf graf--p graf-after--p">Note that the tokens that have been created on chain B are not actually real tokens X, as token X only exists on chain A. They are a representation on B of tokens X from chain A, along with a proof that these tokens are frozen on chain A.</p><p name="7f0c" id="7f0c" class="graf graf--p graf-after--p">A similar mechanism is used to unlock tokens when they come back to their origin chain. For a more comprehensive description of the IBC protocol, you can look at this <a href="https://github.com/cosmos/cosmos-sdk/tree/feature/ibc/docs/spec/ibc" data-href="https://github.com/cosmos/cosmos-sdk/tree/feature/ibc/docs/spec/ibc" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">specification</a>. It is worth mentioning that the IBC protocol we have described is for value transfer only, i.e. sending tokens from one chain to the other, but that it might later be extended to support logic transfer as well.</p><h4 name="ffab" id="ffab" class="graf graf--h4 graf-after--p">Cosmos — Hubs and Zones</h4><p name="f4d3" id="f4d3" class="graf graf--p graf-after--h4">Now that we have a protocol that allows two heterogenous chains to exchange tokens with each other, how do we create a network of blockchains?</p><p name="ca81" id="ca81" class="graf graf--p graf-after--p">One idea would be to connect each blockchain in the network with every other via a direct IBC connection. There are two problems with this approach:</p><ul class="postList"><li name="b34f" id="b34f" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Number of connections:</strong> If there are 100 blockchains in the network and each of them needs to maintain an IBC connection with each other, that’s 4950 connections. This quickly gets out of hand.</li><li name="f088" id="f088" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">High trust requirements:</strong> When a blockchain receives a token from the chain that created it, only one level of trust is required. Indeed, the receiving chain only has to trust the validator set of the origin chain not to unfreeze or double spend the tokens. But when a blockchain receives a token from a chain that did not create it, several levels of trust are involved. That’s because the receiving chain must not only trust that the origin chain did not unfreeze the token, but also that all the chains that received the token before did not double spend it. As the number of chains relaying the token grows, the number of chains the receiver needs to trust grows as well. This is not practical. One way to solve this is to unfreeze the token, transfer it on the origin chain and then send an IBC transaction. But we can do better.</li></ul><p name="e68b" id="e68b" class="graf graf--p graf-after--li">To solve this, Cosmos proposes a modular architecture with two classes of blockchain: Hubs and Zones. Zones are regular heterogenous blockchains, and Hubs are blockchains specifically used to connect Zones together. When a Zone creates an IBC connexion with a Hub, it can automatically access (i.e. send to and receive from) every other Zone that is connected to it. As a result, each Zone only needs to establish a limited number of connexions with a restricted sets of Hubs. Hubs also prevent double spend among Zones. This means that when a Zone receives a token from a Hub, it needs only trust the origin Zone of this token and the Hub.</p><figure name="653c" id="653c" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 336px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 48%;"></div><img class="graf-image" data-image-id="1*zXQzPLV66KKx6eIMCAPGvw.jpeg" data-width="1000" data-height="480" src="https://cdn-images-1.medium.com/max/800/1*zXQzPLV66KKx6eIMCAPGvw.jpeg"></div><figcaption class="imageCaption">Cosmos — Cosmos Hub and Zones</figcaption></figure><p name="47b3" id="47b3" class="graf graf--p graf-after--figure">The first Hub to launch in the Cosmos Ecosystem will be the Cosmos Hub. The Cosmos Hub is a public Proof-Of-Stake blockchain whose native staking token is called Atom, and where transactions fees will be payable in multiple tokens including Atom and Photon. The launch of the Hub will also mark the launch of the Cosmos network.</p><h4 name="6671" id="6671" class="graf graf--h4 graf-after--p"><strong class="markup--strong markup--h4-strong">Bridging non-Tendermint chains</strong></h4><p name="feb5" id="feb5" class="graf graf--p graf-after--h4">In the architecture of Cosmos we have presented until now, only Tendermint-based chains can interoperate. But the Cosmos is not limited to Tendermint chains. In fact, any kind of blockchain can be connected to Cosmos.</p><p name="4216" id="4216" class="graf graf--p graf-after--p">We have two cases to distinguish: fast-finality chains and probabilistic-finality chains.</p><p name="f158" id="f158" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Fast-finality chains</strong></p><p name="62fe" id="62fe" class="graf graf--p graf-after--p">Blockchains that use fast-finality <em class="markup--em markup--p-em">consensus</em> algorithms can connect with Cosmos by adapting IBC. For example, if Ethereum were to switch to Casper FFG (Friendly Finality Gadget), a direct connection could be established between it and the Cosmos Ecosystem by adapting IBC to work with Casper.</p><p name="7165" id="7165" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Probabilistic-finality chains</strong></p><p name="318d" id="318d" class="graf graf--p graf-after--p">For blockchains that do not have fast-finality, like Proof-Of-Work chains, it gets a bit trickier. For these chains, we use a special kind of <a href="https://blog.cosmos.network/the-internet-of-blockchains-how-cosmos-does-interoperability-starting-with-the-ethereum-peg-zone-8744d4d2bc3f" data-href="https://blog.cosmos.network/the-internet-of-blockchains-how-cosmos-does-interoperability-starting-with-the-ethereum-peg-zone-8744d4d2bc3f" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">proxy-chain called <em class="markup--em markup--p-em">Peg-Zone</em>.</a></p><p name="d887" id="d887" class="graf graf--p graf-after--p">A Peg-Zone is a blockchain that tracks the state of another blockchain. The Peg-Zone itself has fast-finality and is therefore compatible with IBC. Its role is to establish finality for the blockchain that it bridges. Let us take an example to better understand.</p><p name="2b3a" id="2b3a" class="graf graf--p graf-after--p">We want to bridge the Proof-Of-Work Ethereum blockchain so that it is possible to send tokens back and forth between Ethereum and Cosmos. Because Proof-Of-Work Ethereum does not have fast-finality, we need to create a Peg-Zone to bridge it.</p><p name="e63f" id="e63f" class="graf graf--p graf-after--p">First, the Peg-Zone needs to decide on a finality threshold for the origin chain. For example, it can consider that a given state of the origin’s chain is final when 100 blocks have been added after it. On the main Ethereum blockchain, a contract is deployed. It is this specific contract that is tracked by the Peg-Zone. When users want to send tokens from Ethereum to Cosmos, they actually send tokens to this contract. Then, the contract freezes the assets and, 100 blocks after, a representation of these assets is released on the Peg-Zone. A similar mechanism is used to send assets back to the Ethereum chain. Interestingly enough, the Peg-Zone also allows us to send any token that lives on Cosmos to the Ethereum chain (the Cosmos tokens being represented as ERC20 on the Ethereum chain). The Tendermint team is currently working on a Peg-Zone implementation for the Ethereum chain called <a href="https://github.com/cosmos/peggy" data-href="https://github.com/cosmos/peggy" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Peggy</a>.</p><p name="cc72" id="cc72" class="graf graf--p graf-after--p">The problem with Peg-Zones is that they need to be customized for the particular chain they bridge. Building an Ethereum Peg-Zone is relatively simple because Ethereum is account-based and has smart-contracts, but building a Bitcoin Peg-Zone is a bit more challenging. Explaining how to build a Bitcoin-like Peg-Zone is out-of-scope for this article, but know that it is theoretically possible. If you want to learn more about Peg-Zones, you can take a look at this <a href="https://github.com/cosmos/peggy/tree/master/spec" data-href="https://github.com/cosmos/peggy/tree/master/spec" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">spec</a>.</p><figure name="e61e" id="e61e" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 255px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 36.4%;"></div><img class="graf-image" data-image-id="1*gqhdqGDUqw7bRJyafrIg2g.jpeg" data-width="1320" data-height="480" src="https://cdn-images-1.medium.com/max/800/1*gqhdqGDUqw7bRJyafrIg2g.jpeg"></div><figcaption class="imageCaption">Connecting the Ethereum blockchain via a Peg-Zone</figcaption></figure><h3 name="6a47" id="6a47" class="graf graf--h3 graf-after--figure">Cosmos-SDK</h3><p name="09cb" id="09cb" class="graf graf--p graf-after--h3">Up until now, we have presented a set of tools designed to:</p><ol class="postList"><li name="ad78" id="ad78" class="graf graf--li graf-after--p">Make it easy and fast to develop blockchains with Tendermint and the ABCI</li><li name="6cf0" id="6cf0" class="graf graf--li graf-after--li">Make these blockchains interoperable with IBC and Peg-Zones</li></ol><p name="29d4" id="29d4" class="graf graf--p graf-after--li">But is it easy enough to develop blockchains yet? At this point, developers only have to work on the <em class="markup--em markup--p-em">application</em> layer of the blockchain thanks to Tendermint Core, which is already a big improvement in itself. But we can do better.</p><p name="4e67" id="4e67" class="graf graf--p graf-after--p">Developing a blockchain application is not a trivial task. This is why the <a href="https://blog.cosmos.network/cosmos-sdk-alpha-release-9618e9479638" data-href="https://blog.cosmos.network/cosmos-sdk-alpha-release-9618e9479638" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Cosmos-SDK </a>exists. The Cosmos-SDK is a generalized framework to build secure blockchain applications on top of Tendermint. It is based on two major principles:</p><ul class="postList"><li name="61b0" id="61b0" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Composability:</strong> The goal of the Cosmos-SDK is to create an ecosystem of modules that allow developers to easily spin up sidechains without having to code every single functionality of their application. Anyone can create a module for the Cosmos-SDK, and using already-built modules in your blockchain is as simple as importing them into your application. For example, the Tendermint team is building a set of basic modules that are needed for the Cosmos Hub, like staking, IBC, and governance. These modules can be used by any developer who wants to develop the <em class="markup--em markup--li-em">application</em> layer of a Tendermint blockchain. As a developer, you only have to create the specialized modules required by your application that do not already exist. As the Cosmos network develops, we expect the module ecosystem to gracefully expand, making it easier and easier to develop complex blockchain applications. A tutorial explaining how to code a Cosmos-SDK module will be available soon.</li><li name="557d" id="557d" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Capabilities based security:</strong> Capabilities constrain the security boundaries between modules, enabling developers to better reason about the composability of modules and limit the scope of malicious or unexpected interactions. For a deeper look at capabilities, you can read this cool <a href="http://habitatchronicles.com/2017/05/what-are-capabilities/" data-href="http://habitatchronicles.com/2017/05/what-are-capabilities/" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">article</a>. We will also release an article detailing the use of capabilities based security in the SDK soon</li></ul><figure name="4c56" id="4c56" class="graf graf--figure graf-after--li"><div class="aspectRatioPlaceholder is-locked" style="max-width: 460px; max-height: 360px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 78.3%;"></div><img class="graf-image" data-image-id="1*TK54bxWDennWamJqPZW2xQ.jpeg" data-width="460" data-height="360" src="https://cdn-images-1.medium.com/max/800/1*TK54bxWDennWamJqPZW2xQ.jpeg"></div><figcaption class="imageCaption">Simplified architecture of a Cosmos-SDK based blockchain</figcaption></figure><p name="aebd" id="aebd" class="graf graf--p graf-after--figure">The Cosmos-SDK also comes with a set of nice tools like Command-Line Interface, REST Server, as well as a bunch of useful libraries like HSM libraries.</p><p name="1907" id="1907" class="graf graf--p graf-after--p">What is the tradeoff? For now, the Cosmos-SDK only exists in Golang. This means you will have to code your application in Go if you want to use it. In the future, we expect that the SDK will be implemented in other programming languages. For now, if you don’t want to use Go, you will have to build an ABCI application from scratch. Note that if you want to use Javascript, we have a cool alternative framework called <a href="https://lotionjs.com/" data-href="https://lotionjs.com/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">LotionJS</a>.</p><p name="3462" id="3462" class="graf graf--p graf-after--p">One final remark: the Cosmos-SDK, like all Cosmos tools, was designed to be modular. Today, it allows developers to build on top of the Tendermint consensus engine. However, it can be used with other consensus engines. As time goes by, we expect multiple SDKs to emerge, built with different architecture models and compatible with multiple consensus engines. All within a single ecosystem: Cosmos.</p><h3 name="f131" id="f131" class="graf graf--h3 graf-after--p"><strong class="markup--strong markup--h3-strong">Scalability</strong></h3><p name="1bf1" id="1bf1" class="graf graf--p graf-after--h3">Now that we can easily create and connect blockchains, what is left? You probably guessed it from reading the section’s title: Scalability. Today’s blockchains don’t scale, and that has become one of the biggest pain points of the blockchain ecosystem, if not the biggest.</p><p name="b4d1" id="b4d1" class="graf graf--p graf-after--p">Cosmos leverages two types of scalability:</p><ul class="postList"><li name="9347" id="9347" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Vertical scalability:</strong> This encompasses the methods for scaling the blockchain itself. By moving away from Proof-Of-Work and optimising its components, Tendermint Core can attain thousands of transactions per-second. The bottleneck factor really is the application itself. So, for example, an application like a Virtual Machine (e.g. the Ethereum Virtual Machine) will impose a much lower limit on the transaction throughput than an application where transaction types and state transition functions are directly embedded in it (e.g. a standard Cosmos-SDK application). This is one of the reasons why application-specific blockchains make sense (find out the other reasons <a href="https://medium.com/@gautier_md/why-application-specific-blockchains-make-sense-32f2073bfb37" data-href="https://medium.com/@gautier_md/why-application-specific-blockchains-make-sense-32f2073bfb37" class="markup--anchor markup--li-anchor" target="_blank">here</a>).</li><li name="f544" id="f544" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Horizontal scalability: </strong>Even if the consensus engine and the application are highly optimised, at some point, the transaction throughput of a single chain inevitably hits a wall it can’t surpass. That’s the limit of Horizontal scalability. To go beyond it, we have to introduce multi-chains architectures. The idea is to have multiple parallel chains running the same application and operated by a common validator set, making blockchains theoretically indefinitely scalable. Details about horizontal scalability are fairly complex and out-of-scope for this article.</li></ul><p name="74fa" id="74fa" class="graf graf--p graf-after--li">Cosmos will offer vertical scalability at launch, which will be a major scalability improvement in itself. Later, horizontal scalability solutions will be implemented.</p><p name="482b" id="482b" class="graf graf--p graf-after--p">At this point, some might be wondering: Why bother creating a blockchain when I can just deploy my decentralised application on top of an Virtual-Machine blockchain and make this underlying blockchain scale? This is a justified question, considering that most decentralised application today are developed on top of Virtual-Machine blockchains like Ethereum. We believe this is mainly due to the fact that up until now, blockchains were much more difficult to develop than Smart Contracts. But not anymore! Thanks to the Cosmos-SDK, you can easily deploy application-specific blockchains. To learn more about application-specific blockchains and why they make sense, you can read <a href="https://medium.com/@gautier_md/why-application-specific-blockchains-make-sense-32f2073bfb37" data-href="https://medium.com/@gautier_md/why-application-specific-blockchains-make-sense-32f2073bfb37" class="markup--anchor markup--p-anchor" target="_blank">this post</a>. Of course, if you don’t want to build your own blockchain, you can still make your Smart Contracts compatible with Cosmos by deploying them on <a href="https://ethermint.zone/" data-href="https://ethermint.zone/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Ethermint</a>.</p><h3 name="c38f" id="c38f" class="graf graf--h3 graf-after--p">Cosmos in 3 points</h3><p name="cc1b" id="cc1b" class="graf graf--p graf-after--h3">We have covered most of the building blocks of Cosmos. Let us try to recap and summarise what Cosmos is about in three concise points:</p><ol class="postList"><li name="c9cf" id="c9cf" class="graf graf--li graf-after--p">Make blockchains powerful and easy to develop with Tendermint and the modularity of the Cosmos-SDK</li><li name="33d2" id="33d2" class="graf graf--li graf-after--li">Enable blockchains to transfer value with each other with IBC and Peg-Zones, while retaining their sovereignty</li><li name="63b7" id="63b7" class="graf graf--li graf-after--li">Make blockchain applications scalable with both horizontal and vertical scalability.</li></ol><p name="c453" id="c453" class="graf graf--p graf-after--li">More than anything, Cosmos is not a product. It is an <strong class="markup--strong markup--p-strong">ecosystem</strong> built on a set of modular, adaptable and interchangeable tools. Developers are encouraged to join the effort to improve existing tools and create new ones to make the original promise of blockchain technology a reality. These tools are the foundation needed to create the decentralised internet and global financial system of tomorrow.</p><h3 name="9b5f" id="9b5f" class="graf graf--h3 graf-after--p">Back to Earth</h3><p name="f06a" id="f06a" class="graf graf--p graf-after--h3">Now that we have presented the Cosmos vision and given a sense of its potential, let us materialise it with a few concrete examples.</p><h4 name="5478" id="5478" class="graf graf--h4 graf-after--p">Fundraiser Zone</h4><p name="ecdb" id="ecdb" class="graf graf--p graf-after--h4">Let us say we want to build an ICO Zone on Cosmos. This Zone would be able to accept virtually any existing token while maintaining transparency and decentralised custody for backers. Also, it would scale and not run concurrently to other decentralised applications. In short, users would be able to participate in all ICOs from a single, highly-performant platform.</p><p name="c1dc" id="c1dc" class="graf graf--p graf-after--p">We want to ease our lives as developers and therefore choose to build on top of the Cosmos-SDK. Our ICO Zone is a public Proof-Of-Stake Zone, which means it needs the following modules:</p><ul class="postList"><li name="443f" id="443f" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Staking</strong>: To handle Proof-Of-Stake</li><li name="b913" id="b913" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Accounts and Bank</strong>: To keep track of each user’s coins</li><li name="6dd0" id="6dd0" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Governance</strong>: To manage upgrades and contentious issues</li><li name="4b4c" id="4b4c" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">IBC</strong>: To send and receive tokens</li></ul><p name="657d" id="657d" class="graf graf--p graf-after--li">We are lucky! These are already available, we don’t need to code them again. The only thing we need to do is to create an ICO module for our specific application. This shouldn’t be too hard! (A tutorial on how to code a SDK-module will be available soon).</p><p name="3200" id="3200" class="graf graf--p graf-after--p">And that is it! Coding a fully-fledged public, interoperable and scalable blockchain just boiled down to coding a simple module. Now we still have to develop the front-end for our blockchain application, but this is not the hardest part.</p><p name="5bc5" id="5bc5" class="graf graf--p graf-after--p">If we are nice, we can also open source and document our ICO module, so that other developers can import it in their application to support its functionalities.</p><p name="84ab" id="84ab" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Decentralised Exchange</strong></p><p name="f45e" id="f45e" class="graf graf--p graf-after--p">A decentralised exchange is the holy grail of cryptocurrency exchanges. With such an exchange, users would always be in control of their funds, unlike current centralised exchanges where users entrust their funds with exchange operators.</p><p name="9b36" id="9b36" class="graf graf--p graf-after--p">Building a decentralised exchange on Cosmos is fairly simple. The blockchain part of the exchange will deal with funds custody and clearing. As for order matching, it will still be handled by centralised operators to allow for a satisfying user experience and deep order book (see this <a href="https://github.com/cosmos/cosmos/blob/master/DEX.md" data-href="https://github.com/cosmos/cosmos/blob/master/DEX.md" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">doc</a> for more background on this model).</p><p name="40d9" id="40d9" class="graf graf--p graf-after--p">We want our decentralised exchange to support FIAT-token. The problem with FIAT-token is that they are submitted to regulations, and therefore can’t be emitted on public blockchains. As a result, our decentralised exchange will have a 2-chains infrastructure. One chain will be a private Proof-Of-Authority chain that handles FIAT-tokens, and the other will be a public Proof-Of-Stake chain for crypto-to-crypto trading, both running on top of Tendermint Core. These two chains will be connected together and to the Cosmos Hub via IBC connexions.</p><p name="7808" id="7808" class="graf graf--p graf-after--p">Now what do we need to do to build such a complex infrastructure? Not much, actually. The staking, governance, accounts, bank and IBC modules that we need already exist. What we need to code is:</p><ul class="postList"><li name="27fb" id="27fb" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">A Proof-Of-Authority module:</strong> To have private validator set for our FIAT-chain.</li><li name="bc7d" id="bc7d" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">A FIAT-token module:</strong> To handle emission and transfer of FIAT-tokens according to the regulations of my specific jurisdiction.</li><li name="69ce" id="69ce" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">A settlement module:</strong> To allow settlement of trades between tokens on both chains</li></ul><p name="9b04" id="9b04" class="graf graf--p graf-after--li">With these three modules, we have the building blocks we need to deploy the base blockchain layer of our decentralised exchange architecture.</p><p name="6858" id="6858" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Local currencies</strong></p><p name="4477" id="4477" class="graf graf--p graf-after--p">Let us say 7 US states want to launch their local currencies. In each state, a blockchain would be operated between cities to manage the local currency of the state. Building such a blockchain on Cosmos would be super easy. The modules account, bank and governance already exist. All that is left is to build a Proof-Of-Authority module to enable cities of a given state to run a private chain between each other.</p><p name="6067" id="6067" class="graf graf--p graf-after--p">Now let us say that these 7 states want to interoperate with each other. Easy! All they need to do is deploy a local Hub between them. We would now have 7 blockchains, one in each state, and one Hub that connects them all. All that each state-level blockchain would need to do is import the IBC module and establish a connexion with the Hub.</p><p name="43cc" id="43cc" class="graf graf--p graf-after--p">At this point, the 7 local currencies can flow between the 7 states. But what if these states now want to interoperate with public cryptocurrencies? Nothing complicated: The local Hub just needs to establish an IBC connexion with the Cosmos Hub, and that’s it. Once this connexion is established, public cryptocurrencies can flow through the local Hub to reach the 7 state blockchains. This design has one big advantage: if the Cosmos Hub went down for some reason, the local Hub would still be functioning. The blockchains of the 7 states would not be able to transfer tokens to blockchains connected via the Cosmos Hub, but they would still be able to transact between each other through their local Hub. That is the power of IBC, which allows blockchains to interoperate without losing their sovereignty.</p><h3 name="bbd8" id="bbd8" class="graf graf--h3 graf-after--p">Conclusion</h3><p name="ed5c" id="ed5c" class="graf graf--p graf-after--h3 graf--trailing">These are but a few examples. The potential for Cosmos applications is virtually infinite. Cosmos is designed to be modular, adaptable and scalable. It exists to make the promise of blockchain a reality. Whatever your blockchain use case may be, you will find tools to easily build it on Cosmos. This is not a promise that may come true in a few years, this is available <strong class="markup--strong markup--p-strong">now</strong>.</p></div></div></section>
</section>
<footer><p class="p-tags">Tagged in <a href="https://medium.com/tag/blockchain" class="p-tag">Blockchain</a>, <a href="https://medium.com/tag/ethereum" class="p-tag">Ethereum</a>, <a href="https://medium.com/tag/cosmos-sdk" class="p-tag">Cosmos Sdk</a>, <a href="https://medium.com/tag/tendermint" class="p-tag">Tendermint</a>, <a href="https://medium.com/tag/cosmos" class="p-tag">Cosmos</a></p><p>By <a href="https://medium.com/@gautier_md" class="p-author h-card">Gautier MARIN</a> on <a href="https://medium.com/p/ecaef63350d"><time class="dt-published" datetime="2018-04-03T14:29:20.022Z">April 3, 2018</time></a>.</p><p><a href="https://medium.com/@gautier_md/understanding-the-value-proposition-of-cosmos-ecaef63350d" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on April 23, 2018.</p></footer></article>

</body></html>